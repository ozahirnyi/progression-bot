# Task 07 — Use real storage path everywhere (Stage 2)

Один файл стану для всіх команд — один JSON на диску.

## Мета

Усі команди, що читають або змінюють стан бота, мають використовувати **один шлях до файлу** з конфігурації (`STORAGE_PATH`, наприклад `./data/state.json`). Тобто `/status`, `/last14`, `/plan`, `/heatmap`, а згодом `/log` та `/start_progression` працюють з одним і тим самим файлом.

## Що має вийти

- Після запуску бота виклик `/status` (або `/last14`, `/plan`) бере стан з `STORAGE_PATH`. Зміни у файлі (вручну або через майбутній `/log`) відображаються при наступній команді.
- Handlers (або роутер) отримують шлях до сховища з конфігурації; у тестах можна підставляти тимчасовий шлях або фікстуру, щоб не чіпати реальні дані.
- Якщо файл стану ще не існує, завантаження має створювати файл з дефолтним станом (як у task_03) або повертати дефолтний стан і створювати файл при першому збереженні.

## Контракт для тестів

Тести перевіряють:

- Що handlers (або застосунок) приймають конфігурований шлях до сховища (наприклад, передається при створенні).
- Що завантаження з шляху, де файлу ще немає, призводить до створення дефолтного стану або створення файлу.
- Що запис стану в тимчасовий файл і виклик handler з цим шляхом дають очікувані дані (наприклад, правильна кількість записів або `start_date`).

Ти сам обираєш, де зберігати шлях (клас handlers, роутер, конфіг) і як передавати його в `JsonStore` — головне, щоб не було захардкодженого `fixtures/mock_state.json` для “боєвого” режиму.

## Підказки

- У конфігу вже є поле для шляху до сховища; у `main.py` його можна передавати при створенні Handlers/ Router.
- Для тестів можна використовувати `tmp_path` (pytest) або окремий шлях до фікстури.
