# Task 08 — Make `/log` persist (Stage 2)

Якщо час залогили, але не зберегли в JSON — чи він взагалі був?

## Мета

Коли користувач надсилає `/log 2h` (або `/log yesterday 45m`, тощо), бот має **оновити реальний файл стану** і підтвердити це повідомленням. Парсиш команду, додаєш (або підсумовуєш) хвилини за відповідний день, зберігаєш стан, відповідаєш коротким підтвердженням.

## Що має вийти

- `/log 2h` та інші варіанти оновлюють файл за `STORAGE_PATH` і відповідають підтвердженням.
- Після перезапуску бота `/status` та `/last14` показують нові хвилини.
- Якщо за один день логують двічі — хвилини підсумовуються (або інше чітке правило, яке ти обереш і задокументуєш).
- Невірний формат або відсутність тривалості дають зрозуміле повідомлення (на кшталт "Usage: /log 2h or /log yesterday 45m"), без крашу.

## Контракт для тестів

Тести очікують у модулі `progression_bot.use_cases.progress`:

- **`LogRequest`** — dataclass з полями `day: date`, `minutes: int`, `note: str | None = None`.
- **`log_time(state: State, req: LogRequest) -> State`** — повертає новий стан, у якому для `req.day` додано `req.minutes` (наприклад, сума з існуючим записом або один запис на день).
- **`upsert_entry(state: State, entry: Entry) -> State`** — вставляє або оновлює запис для `entry.day`; у результаті для цього дня в `state.entries` є відповідний запис з `entry.minutes`.

Де саме реалізувати (`progress.py` чи інший модуль), як саме підсумовувати хвилини і чи використовувати `upsert_entry` всередині `log_time` — твій вибір. Роутер/хендлер має: завантажити стан, розпарсити текст (наприклад, через `parse_log_command` з task_02), викликати use case, зберегти стан, повернути текст відповіді.

## Підказки

- Можна використовувати `parse_log_command` з task_02; для "сьогодні" — `date.today()` або ін’єктована дата в тестах.
- State — immutable: `log_time` повертає **новий** `State` з оновленими `entries`, не змінюй старий.
